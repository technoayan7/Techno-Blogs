---
Id: 1020
Title: Complete MCP Server Guide - From Basics to Building Your Own
Author: technoayan
Tags: MCP Server AI Integration Protocol Development
Topic: MCP Server
Abstract: A comprehensive beginner's guide to MCP (Model Context Protocol) servers covering everything from basic concepts to building your own custom server with practical examples and real-world applications.
HeaderImage: /MCPlogo.png
isPublished: true
---

# 🚀 Complete MCP Server Guide - From Basics to Building Your Own

Welcome to the fascinating world of MCP Servers! If you've ever wondered how AI applications connect to external tools and services, or how to build your own AI-powered integrations, this guide will take you from complete beginner to MCP server developer.

## 🤔 What is MCP Server? {#What-is-MCP-Server}

MCP (Model Context Protocol) Server is like a universal translator that helps AI models communicate with external tools, databases, and services. Think of it as a bridge between your AI assistant and the outside world.

Real-life analogy: Imagine you're at a fancy restaurant in a foreign country. The MCP server is like a multilingual waiter who:
- 🗣️ Understands what you want (AI model requests)
- 🔧 Knows how to get it from the kitchen (external tools/services)
- 📋 Brings back exactly what you ordered (structured responses)

### 🎯 Why MCP Servers Matter:
- 🔌 Connectivity: Connect AI to databases, APIs, file systems
- 🛡️ Security: Controlled access to external resources
- 🔄 Standardization: Universal protocol for AI integrations
- ⚡ Efficiency: Optimized communication between AI and tools

Real-world example: Instead of manually copying data from your database to show an AI, an MCP server lets the AI directly query your database safely and efficiently.

## 🏗️ How MCP Servers Work {#How-MCP-Servers-Work}

### 🎭 The Three Main Characters:

1. 🤖 AI Client (Claude, ChatGPT, etc.)
2. 🌉 MCP Server (The bridge we're building)
3. 🔧 Tools/Resources (Databases, APIs, files)

```
🤖 AI Client ←→ 🌉 MCP Server ←→ 🔧 External Tools
   "Get user data"   "I'll handle it"   "Here's the data"
```

Real-life analogy: It's like ordering food delivery:
- AI Client = You (placing the order)
- MCP Server = Delivery service (handles the logistics)
- External Tools = Restaurant (provides the actual service)

### 📡 Communication Flow:

```go
// Simplified flow
1. AI sends request → MCP Server
2. MCP Server processes → External Tool
3. External Tool responds → MCP Server
4. MCP Server formats → AI Client
```

## 🛠️ Setting Up Your First MCP Server {#Setting-Up-MCP-Server}

### 📋 Prerequisites:
- Node.js (v16+) or Python (3.8+)
- Basic programming knowledge
- Text editor (VS Code recommended)

### 🚀 Quick Start with Node.js:

```bash
# 📦 Create new project
mkdir my-mcp-server
cd my-mcp-server

# 🔧 Initialize project
npm init -y

# 📥 Install MCP SDK
npm install @modelcontextprotocol/sdk
```

### 🎯 Your First MCP Server:

```javascript
// server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

// 🎪 Create server instance
const server = new Server(
  {
    name: 'my-first-mcp-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
      resources: {},
    },
  }
);

// 🔧 Add a simple tool
server.setRequestHandler('tools/list', async () => {
  return {
    tools: [
      {
        name: 'greet',
        description: '👋 Say hello to someone',
        inputSchema: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'Name of the person to greet',
            },
          },
          required: ['name'],
        },
      },
    ],
  };
});

// 🎯 Handle tool calls
server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;

  if (name === 'greet') {
    const personName = args.name;
    return {
      content: [
        {
          type: 'text',
          text: `🎉 Hello, ${personName}! Welcome to MCP Server world!`,
        },
      ],
    };
  }

  throw new Error(`Unknown tool: ${name}`);
});

// 🚀 Start the server
const transport = new StdioServerTransport();
server.connect(transport);

console.log('🌟 MCP Server started! Ready to serve AI requests...');
```

Real-life analogy: This is like setting up a help desk that can answer one question: "How to greet people?" When someone asks, it provides a personalized greeting.

## 🎯 Understanding MCP Tools {#Understanding-MCP-Tools}

### 🔧 What are Tools?
Tools are functions that your MCP server can execute on behalf of the AI. Think of them as special abilities you give to the AI.

### 🛠️ Building a Calculator Tool:

```javascript
// calculator-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const server = new Server(
  {
    name: 'calculator-mcp-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// 🔢 List available calculator tools
server.setRequestHandler('tools/list', async () => {
  return {
    tools: [
      {
        name: 'add',
        description: '➕ Add two numbers',
        inputSchema: {
          type: 'object',
          properties: {
            a: { type: 'number', description: 'First number' },
            b: { type: 'number', description: 'Second number' },
          },
          required: ['a', 'b'],
        },
      },
      {
        name: 'multiply',
        description: '✖️ Multiply two numbers',
        inputSchema: {
          type: 'object',
          properties: {
            a: { type: 'number', description: 'First number' },
            b: { type: 'number', description: 'Second number' },
          },
          required: ['a', 'b'],
        },
      },
      {
        name: 'calculate_tip',
        description: '💰 Calculate tip for a bill',
        inputSchema: {
          type: 'object',
          properties: {
            billAmount: { type: 'number', description: 'Bill amount' },
            tipPercent: { type: 'number', description: 'Tip percentage' },
          },
          required: ['billAmount', 'tipPercent'],
        },
      },
    ],
  };
});

// 🎯 Handle calculator operations
server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;

  switch (name) {
    case 'add':
      const sum = args.a + args.b;
      return {
        content: [
          {
            type: 'text',
            text: `➕ ${args.a} + ${args.b} = ${sum}`,
          },
        ],
      };

    case 'multiply':
      const product = args.a * args.b;
      return {
        content: [
          {
            type: 'text',
            text: `✖️ ${args.a} × ${args.b} = ${product}`,
          },
        ],
      };

    case 'calculate_tip':
      const tip = args.billAmount * (args.tipPercent / 100);
      const total = args.billAmount + tip;
      return {
        content: [
          {
            type: 'text',
            text: `💰 Bill: $${args.billAmount.toFixed(2)}\n💵 Tip (${args.tipPercent}%): $${tip.toFixed(2)}\n💳 Total: $${total.toFixed(2)}`,
          },
        ],
      };

    default:
      throw new Error(`Unknown tool: ${name}`);
  }
});

// 🚀 Start server
const transport = new StdioServerTransport();
server.connect(transport);

console.log('🔢 Calculator MCP Server ready!');
```

Real-life analogy: This is like having a smart calculator that not only does math but also explains what it's doing and can handle real-world scenarios like tip calculations.

## 📚 Working with Resources {#Working-with-Resources}

### 📋 What are Resources?
Resources are data sources that your MCP server can read from. Think of them as information libraries that the AI can access.

### 📁 File System Resource Example:

```javascript
// file-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import fs from 'fs/promises';
import path from 'path';

const server = new Server(
  {
    name: 'file-mcp-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      resources: {},
    },
  }
);

// 📂 List available files
server.setRequestHandler('resources/list', async () => {
  try {
    const files = await fs.readdir('./documents');
    return {
      resources: files.map(file => ({
        uri: `file://${file}`,
        name: file,
        description: `📄 Document: ${file}`,
        mimeType: 'text/plain',
      })),
    };
  } catch (error) {
    return { resources: [] };
  }
});

// 📖 Read file content
server.setRequestHandler('resources/read', async (request) => {
  const { uri } = request.params;
  const fileName = uri.replace('file://', '');
  const filePath = path.join('./documents', fileName);

  try {
    const content = await fs.readFile(filePath, 'utf8');
    return {
      contents: [
        {
          uri,
          mimeType: 'text/plain',
          text: content,
        },
      ],
    };
  } catch (error) {
    throw new Error(`Could not read file: ${fileName}`);
  }
});

// 🔧 Add a tool to create files
server.setRequestHandler('tools/list', async () => {
  return {
    tools: [
      {
        name: 'create_file',
        description: '📝 Create a new text file',
        inputSchema: {
          type: 'object',
          properties: {
            filename: { type: 'string', description: 'Name of the file' },
            content: { type: 'string', description: 'File content' },
          },
          required: ['filename', 'content'],
        },
      },
    ],
  };
});

server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;

  if (name === 'create_file') {
    const filePath = path.join('./documents', args.filename);
    await fs.writeFile(filePath, args.content, 'utf8');
    return {
      content: [
        {
          type: 'text',
          text: `✅ File '${args.filename}' created successfully!`,
        },
      ],
    };
  }

  throw new Error(`Unknown tool: ${name}`);
});

// 🚀 Start server
const transport = new StdioServerTransport();
server.connect(transport);

console.log('📁 File MCP Server ready!');
```

Real-life analogy: This is like having a librarian who can both find books for you to read and help you write new books to add to the library.

## 🌐 Database Integration MCP Server {#Database-Integration}

### 🗄️ SQLite Database Example:

```javascript
// database-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';

// 🗄️ Database setup
let db;

async function initDatabase() {
  db = await open({
    filename: './users.db',
    driver: sqlite3.Database,
  });

  // 📋 Create users table
  await db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      age INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // 📊 Insert sample data
  await db.run(`
    INSERT OR IGNORE INTO users (name, email, age) VALUES
    ('Alice Johnson', 'alice@example.com', 28),
    ('Bob Smith', 'bob@example.com', 35),
    ('Charlie Brown', 'charlie@example.com', 22)
  `);
}

const server = new Server(
  {
    name: 'database-mcp-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
      resources: {},
    },
  }
);

// 🔧 Database tools
server.setRequestHandler('tools/list', async () => {
  return {
    tools: [
      {
        name: 'get_users',
        description: '👥 Get all users from database',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'add_user',
        description: '➕ Add a new user',
        inputSchema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'User name' },
            email: { type: 'string', description: 'User email' },
            age: { type: 'number', description: 'User age' },
          },
          required: ['name', 'email', 'age'],
        },
      },
      {
        name: 'search_users',
        description: '🔍 Search users by name',
        inputSchema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Name to search for' },
          },
          required: ['name'],
        },
      },
    ],
  };
});

// 🎯 Handle database operations
server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'get_users':
        const users = await db.all('SELECT * FROM users ORDER BY created_at DESC');
        return {
          content: [
            {
              type: 'text',
              text: `👥 Found ${users.length} users:\n\n` +
                users.map(user =>
                  `📋 ${user.name} (${user.age} years old)\n` +
                  `   📧 ${user.email}\n` +
                  `   🕒 Joined: ${user.created_at}`
                ).join('\n\n'),
            },
          ],
        };

      case 'add_user':
        const result = await db.run(
          'INSERT INTO users (name, email, age) VALUES (?, ?, ?)',
          [args.name, args.email, args.age]
        );

        return {
          content: [
            {
              type: 'text',
              text: `✅ User '${args.name}' added successfully! (ID: ${result.lastID})`,
            },
          ],
        };

      case 'search_users':
        const searchResults = await db.all(
          'SELECT * FROM users WHERE name LIKE ? ORDER BY name',
          [`%${args.name}%`]
        );

        if (searchResults.length === 0) {
          return {
            content: [
              {
                type: 'text',
                text: `❌ No users found matching '${args.name}'`,
              },
            ],
          };
        }

        return {
          content: [
            {
              type: 'text',
              text: `🔍 Found ${searchResults.length} users matching '${args.name}':\n\n` +
                searchResults.map(user =>
                  `📋 ${user.name} (${user.age} years old) - ${user.email}`
                ).join('\n'),
            },
          ],
        };

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `❌ Database error: ${error.message}`,
        },
      ],
    };
  }
});

// 🚀 Initialize and start server
async function startServer() {
  await initDatabase();
  const transport = new StdioServerTransport();
  server.connect(transport);
  console.log('🗄️ Database MCP Server ready!');
}

startServer();
```

Real-life analogy: This is like having a smart receptionist who can look up customer information, add new customers, and search through records - all while speaking the AI's language.

## 🌤️ Weather API MCP Server {#Weather-API-Server}

### 🌡️ External API Integration:

```javascript
// weather-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import fetch from 'node-fetch';

const server = new Server(
  {
    name: 'weather-mcp-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// 🌤️ Weather tools
server.setRequestHandler('tools/list', async () => {
  return {
    tools: [
      {
        name: 'get_weather',
        description: '🌤️ Get current weather for a city',
        inputSchema: {
          type: 'object',
          properties: {
            city: { type: 'string', description: 'City name' },
            country: { type: 'string', description: 'Country code (optional)' },
          },
          required: ['city'],
        },
      },
      {
        name: 'get_weather_forecast',
        description: '📊 Get 5-day weather forecast',
        inputSchema: {
          type: 'object',
          properties: {
            city: { type: 'string', description: 'City name' },
            country: { type: 'string', description: 'Country code (optional)' },
          },
          required: ['city'],
        },
      },
    ],
  };
});

// 🎯 Handle weather requests
server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;

  // Note: You'll need to get a free API key from openweathermap.org
  const API_KEY = 'YOUR_API_KEY_HERE';
  const BASE_URL = 'https://api.openweathermap.org/data/2.5';

  try {
    switch (name) {
      case 'get_weather':
        const location = args.country ? `${args.city},${args.country}` : args.city;
        const weatherResponse = await fetch(
          `${BASE_URL}/weather?q=${location}&appid=${API_KEY}&units=metric`
        );

        if (!weatherResponse.ok) {
          throw new Error(`Weather API error: ${weatherResponse.status}`);
        }

        const weatherData = await weatherResponse.json();
        const temp = Math.round(weatherData.main.temp);
        const feelsLike = Math.round(weatherData.main.feels_like);
        const humidity = weatherData.main.humidity;
        const description = weatherData.weather[0].description;

        // 🌡️ Get weather emoji
        const getWeatherEmoji = (main) => {
          const emojis = {
            'Clear': '☀️',
            'Clouds': '☁️',
            'Rain': '🌧️',
            'Snow': '❄️',
            'Thunderstorm': '⛈️',
            'Drizzle': '🌦️',
            'Mist': '🌫️',
            'Fog': '🌫️',
          };
          return emojis[main] || '🌤️';
        };

        const emoji = getWeatherEmoji(weatherData.weather[0].main);

        return {
          content: [
            {
              type: 'text',
              text: `${emoji} Weather in ${weatherData.name}, ${weatherData.sys.country}\n\n` +
                `🌡️ Temperature: ${temp}°C (feels like ${feelsLike}°C)\n` +
                `☁️ Condition: ${description}\n` +
                `💧 Humidity: ${humidity}%\n` +
                `🌪️ Wind: ${weatherData.wind.speed} m/s\n` +
                `👁️ Visibility: ${(weatherData.visibility / 1000).toFixed(1)} km`,
            },
          ],
        };

      case 'get_weather_forecast':
        const forecastLocation = args.country ? `${args.city},${args.country}` : args.city;
        const forecastResponse = await fetch(
          `${BASE_URL}/forecast?q=${forecastLocation}&appid=${API_KEY}&units=metric`
        );

        if (!forecastResponse.ok) {
          throw new Error(`Forecast API error: ${forecastResponse.status}`);
        }

        const forecastData = await forecastResponse.json();
        const dailyForecasts = {};

        // 📊 Group by day
        forecastData.list.forEach(item => {
          const date = new Date(item.dt * 1000).toDateString();
          if (!dailyForecasts[date]) {
            dailyForecasts[date] = {
              temps: [],
              conditions: [],
              humidity: [],
            };
          }
          dailyForecasts[date].temps.push(item.main.temp);
          dailyForecasts[date].conditions.push(item.weather[0].main);
          dailyForecasts[date].humidity.push(item.main.humidity);
        });

        // 📈 Create forecast summary
        const forecastSummary = Object.entries(dailyForecasts)
          .slice(0, 5)
          .map(([date, data]) => {
            const avgTemp = Math.round(data.temps.reduce((a, b) => a + b) / data.temps.length);
            const maxTemp = Math.round(Math.max(...data.temps));
            const minTemp = Math.round(Math.min(...data.temps));
            const mostCommonCondition = data.conditions.sort((a, b) =>
              data.conditions.filter(v => v === a).length - data.conditions.filter(v => v === b).length
            ).pop();

            const emoji = getWeatherEmoji(mostCommonCondition);
            const dayName = new Date(date).toLocaleDateString('en-US', { weekday: 'long' });

            return `${emoji} ${dayName}: ${minTemp}°C - ${maxTemp}°C (${mostCommonCondition})`;
          })
          .join('\n');

        return {
          content: [
            {
              type: 'text',
              text: `📊 5-Day Weather Forecast for ${forecastData.city.name}\n\n${forecastSummary}`,
            },
          ],
        };

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `❌ Weather service error: ${error.message}`,
        },
      ],
    };
  }
});

// 🚀 Start server
const transport = new StdioServerTransport();
server.connect(transport);

console.log('🌤️ Weather MCP Server ready!');
```

Real-life analogy: This is like having a personal meteorologist who can check the weather anywhere in the world and give you detailed forecasts in a format that's easy to understand.

## 🔒 Security Best Practices {#Security-Best-Practices}

### 🛡️ Essential Security Measures:

```javascript
// secure-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import crypto from 'crypto';

// 🔐 Configuration with security settings
const CONFIG = {
  MAX_REQUEST_SIZE: 1024 * 1024, // 1MB limit
  RATE_LIMIT: 100, // requests per minute
  ALLOWED_OPERATIONS: ['read', 'search'], // No write operations
  ENCRYPTION_KEY: process.env.ENCRYPTION_KEY || 'your-secret-key',
};

class SecureMCPServer {
  constructor() {
    this.requestCounts = new Map();
    this.server = new Server(
      {
        name: 'secure-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  // 🔒 Rate limiting
  checkRateLimit(clientId) {
    const now = Date.now();
    const windowStart = now - 60000; // 1 minute window

    if (!this.requestCounts.has(clientId)) {
      this.requestCounts.set(clientId, []);
    }

    const requests = this.requestCounts.get(clientId);
    const recentRequests = requests.filter(time => time > windowStart);

    if (recentRequests.length >= CONFIG.RATE_LIMIT) {
      throw new Error('🚫 Rate limit exceeded. Try again later.');
    }

    recentRequests.push(now);
    this.requestCounts.set(clientId, recentRequests);
  }

  // 🧹 Input sanitization
  sanitizeInput(input) {
    if (typeof input !== 'string') return input;

    // Remove potential harmful characters
    return input
      .replace(/[<>\"']/g, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+=/gi, '')
      .trim();
  }

  // 🔐 Encrypt sensitive data
  encryptData(data) {
    const cipher = crypto.createCipher('aes-256-cbc', CONFIG.ENCRYPTION_KEY);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
  }

  // 🔓 Decrypt sensitive data
  decryptData(encryptedData) {
    const decipher = crypto.createDecipher('aes-256-cbc', CONFIG.ENCRYPTION_KEY);
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }

  // 🔧 Setup secure handlers
  setupHandlers() {
    this.server.setRequestHandler('tools/list', async () => {
      return {
        tools: [
          {
            name: 'secure_search',
            description: '🔍 Search data securely',
            inputSchema: {
              type: 'object',
              properties: {
                query: {
                  type: 'string',
                  description: 'Search query',
                  maxLength: 100,
                },
              },
              required: ['query'],
            },
          },
        ],
      };
    });

    this.server.setRequestHandler('tools/call', async (request) => {
      const clientId = request.meta?.clientId || 'unknown';

      try {
        // 🚦 Check rate limit
        this.checkRateLimit(clientId);

        const { name, arguments: args } = request.params;

        if (name === 'secure_search') {
          // 🧹 Sanitize input
          const sanitizedQuery = this.sanitizeInput(args.query);

          // 📊 Validate query length
          if (sanitizedQuery.length > 100) {
            throw new Error('🚫 Query too long. Maximum 100 characters.');
          }

          // 🔍 Perform secure search (example)
          const results = this.performSecureSearch(sanitizedQuery);

          return {
            content: [
              {
                type: 'text',
                text: `🔍 Secure search results for "${sanitizedQuery}":\n\n${results}`,
              },
            ],
          };
        }

        throw new Error(`Unknown tool: ${name}`);

      } catch (error) {
        // 📝 Log security events
        console.error(`Security event - Client: ${clientId}, Error: ${error.message}`);

        return {
          content: [
            {
              type: 'text',
              text: `❌ Security Error: ${error.message}`,
            },
          ],
        };
      }
    });
  }

  // 🔍 Secure search implementation
  performSecureSearch(query) {
    // 🎯 Example: Only allow specific search patterns
    const allowedPatterns = /^[a-zA-Z0-9\s\-_]+$/;

    if (!allowedPatterns.test(query)) {
      throw new Error('🚫 Invalid search pattern');
    }

    // 📊 Mock search results
    const mockResults = [
      '📄 Document 1: Safe content',
      '📋 Report 2: Authorized data',
      '📊 Analysis 3: Public information',
    ];

    return mockResults
      .filter(result => result.toLowerCase().includes(query.toLowerCase()))
      .join('\n') || '❌ No results found';
  }

  // 🚀 Start secure server
  start() {
    const transport = new StdioServerTransport();
    this.server.connect(transport);
    console.log('🔒 Secure MCP Server ready!');
  }
}

// 🌟 Initialize secure server
const secureServer = new SecureMCPServer();
secureServer.start();
```

Real-life analogy: This is like having a bank vault with multiple security layers - you need proper identification, there are limits on transactions, and everything is monitored and encrypted.

## 🧪 Testing Your MCP Server {#Testing-MCP-Server}

### 🔬 Unit Testing Example:

```javascript
// test-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { describe, it, expect, beforeEach } from 'vitest';

describe('MCP Server Tests', () => {
  let server;

  beforeEach(() => {
    server = new Server(
      { name: 'test-server', version: '1.0.0' },
      { capabilities: { tools: {} } }
    );

    // 🔧 Setup test tools
    server.setRequestHandler('tools/list', async () => {
      return {
        tools: [
          {
            name: 'test_tool',
            description: 'Test tool',
            inputSchema: {
              type: 'object',
              properties: {
                input: { type: 'string' },
              },
              required: ['input'],
            },
          },
        ],
      };
    });

    server.setRequestHandler('tools/call', async (request) => {
      const { name, arguments: args } = request.params;

      if (name === 'test_tool') {
        return {
          content: [
            {
              type: 'text',
              text: `Echo: ${args.input}`,
            },
          ],
        };
      }

      throw new Error(`Unknown tool: ${name}`);
    });
  });

  // ✅ Test tool listing
  it('should list available tools', async () => {
    const response = await server.request({
      method: 'tools/list',
      params: {},
    });

    expect(response.tools).toHaveLength(1);
    expect(response.tools[0].name).toBe('test_tool');
  });

  // ✅ Test tool execution
  it('should execute tools correctly', async () => {
    const response = await server.request({
      method: 'tools/call',
      params: {
        name: 'test_tool',
        arguments: { input: 'Hello, Test!' },
      },
    });

    expect(response.content[0].text).toBe('Echo: Hello, Test!');
  });

  // ❌ Test error handling
  it('should handle unknown tools', async () => {
    try {
      await server.request({
        method: 'tools/call',
        params: {
          name: 'unknown_tool',
          arguments: {},
        },
      });
    } catch (error) {
      expect(error.message).toContain('Unknown tool');
    }
  });
});
```

### 🎯 Manual Testing Script:

```javascript
// manual-test.js
import { spawn } from 'child_process';
import { writeFileSync, readFileSync } from 'fs';

class MCPTester {
  constructor(serverPath) {
    this.serverPath = serverPath;
    this.testResults = [];
  }

  // 🧪 Run test cases
  async runTests() {
    console.log('🧪 Starting MCP Server Tests...\n');

    const testCases = [
      {
        name: 'List Tools',
        request: { method: 'tools/list', params: {} },
      },
      {
        name: 'Call Tool',
        request: {
          method: 'tools/call',
          params: {
            name: 'greet',
            arguments: { name: 'Test User' },
          },
        },
      },
      {
        name: 'Invalid Tool',
        request: {
          method: 'tools/call',
          params: {
            name: 'nonexistent',
            arguments: {},
          },
        },
        expectError: true,
      },
    ];

    for (const testCase of testCases) {
      await this.runTestCase(testCase);
    }

    this.generateReport();
  }

  // 🎯 Run individual test case
  async runTestCase(testCase) {
    console.log(`🔍 Testing: ${testCase.name}`);

    try {
      const response = await this.sendRequest(testCase.request);

      if (testCase.expectError) {
        this.testResults.push({
          name: testCase.name,
          status: 'FAIL',
          message: 'Expected error but got success',
        });
        console.log('❌ FAIL - Expected error but got success\n');
      } else {
        this.testResults.push({
          name: testCase.name,
          status: 'PASS',
          response: response,
        });
        console.log('✅ PASS\n');
      }
    } catch (error) {
      if (testCase.expectError) {
        this.testResults.push({
          name: testCase.name,
          status: 'PASS',
          message: 'Expected error occurred',
        });
        console.log('✅ PASS - Expected error occurred\n');
      } else {
        this.testResults.push({
          name: testCase.name,
          status: 'FAIL',
          error: error.message,
        });
        console.log(`❌ FAIL - ${error.message}\n`);
      }
    }
  }

  // 📡 Send request to server
  async sendRequest(request) {
    return new Promise((resolve, reject) => {
      const serverProcess = spawn('node', [this.serverPath]);
      let responseData = '';

      serverProcess.stdout.on('data', (data) => {
        responseData += data.toString();
      });

      serverProcess.stderr.on('data', (data) => {
        reject(new Error(data.toString()));
      });

      serverProcess.on('close', (code) => {
        try {
          const response = JSON.parse(responseData);
          resolve(response);
        } catch (error) {
          reject(new Error('Invalid JSON response'));
        }
      });

      // Send request
      serverProcess.stdin.write(JSON.stringify(request) + '\n');
      serverProcess.stdin.end();
    });
  }

  // 📊 Generate test report
  generateReport() {
    const passed = this.testResults.filter(r => r.status === 'PASS').length;
    const failed = this.testResults.filter(r => r.status === 'FAIL').length;

    console.log('📊 Test Results Summary:');
    console.log(`✅ Passed: ${passed}`);
    console.log(`❌ Failed: ${failed}`);
    console.log(`📋 Total: ${this.testResults.length}\n`);

    if (failed > 0) {
      console.log('❌ Failed Tests:');
      this.testResults
        .filter(r => r.status === 'FAIL')
        .forEach(result => {
          console.log(`- ${result.name}: ${result.error || result.message}`);
        });
    }

    // 💾 Save detailed report
    const report = {
      timestamp: new Date().toISOString(),
      summary: { passed, failed, total: this.testResults.length },
      details: this.testResults,
    };

    writeFileSync('test-report.json', JSON.stringify(report, null, 2));
    console.log('💾 Detailed report saved to test-report.json');
  }
}

// 🚀 Run tests
const tester = new MCPTester('./server.js');
tester.runTests();
```

## 🚀 Deployment and Production {#Deployment-Production}

### 🌐 Docker Deployment:

```dockerfile
# Dockerfile
FROM node:18-alpine

# 📂 Set working directory
WORKDIR /app

# 📦 Copy package files
COPY package*.json ./

# 🔧 Install dependencies
RUN npm ci --only=production

# 📁 Copy application code
COPY . .

# 👤 Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S mcp -u 1001

# 🔐 Set permissions
RUN chown -R mcp:nodejs /app
USER mcp

# 🌍 Expose port (if using HTTP transport)
EXPOSE 3000

# 🏃‍♂️ Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

# 🚀 Start server
CMD ["node", "server.js"]
```

### 🐳 Docker Compose Setup:

```yaml
# docker-compose.yml
version: '3.8'

services:
  mcp-server:
    build: .
    container_name: mcp-server
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - API_KEY=${API_KEY}
      - DATABASE_URL=${DATABASE_URL}
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    networks:
      - mcp-network
    healthcheck:
      test: ["CMD", "node", "healthcheck.js"]
      interval: 30s
      timeout: 10s
      retries: 3

  # 🗄️ Database (if needed)
  database:
    image: postgres:15-alpine
    container_name: mcp-database
    restart: unless-stopped
    environment:
      - POSTGRES_DB=mcpserver
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - mcp-network

  # 📊 Monitoring (optional)
  prometheus:
    image: prom/prometheus:latest
    container_name: mcp-prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    networks:
      - mcp-network

volumes:
  postgres_data:

networks:
  mcp-network:
    driver: bridge
```

### 📊 Monitoring and Logging:

```javascript
// monitoring.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import winston from 'winston';
import promClient from 'prom-client';

// 📊 Metrics setup
const register = new promClient.Registry();
const requestCounter = new promClient.Counter({
  name: 'mcp_requests_total',
  help: 'Total number of MCP requests',
  labelNames: ['method', 'status'],
});

const requestDuration = new promClient.Histogram({
  name: 'mcp_request_duration_seconds',
  help: 'Duration of MCP requests in seconds',
  labelNames: ['method'],
});

register.registerMetric(requestCounter);
register.registerMetric(requestDuration);

// 📝 Logger setup
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'mcp-server' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    }),
  ],
});

class MonitoredMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: 'monitored-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  // 🔧 Setup monitored handlers
  setupHandlers() {
    // 🔧 Tools list with monitoring
    this.server.setRequestHandler('tools/list', async (request) => {
      const timer = requestDuration.startTimer({ method: 'tools/list' });

      try {
        logger.info('Tools list requested');

        const response = {
          tools: [
            {
              name: 'monitored_tool',
              description: '📊 A tool with monitoring',
              inputSchema: {
                type: 'object',
                properties: {
                  input: { type: 'string' },
                },
                required: ['input'],
              },
            },
          ],
        };

        requestCounter.inc({ method: 'tools/list', status: 'success' });
        logger.info('Tools list served successfully');

        return response;
      } catch (error) {
        requestCounter.inc({ method: 'tools/list', status: 'error' });
        logger.error('Error serving tools list', { error: error.message });
        throw error;
      } finally {
        timer();
      }
    });

    // 🎯 Tool call with monitoring
    this.server.setRequestHandler('tools/call', async (request) => {
      const timer = requestDuration.startTimer({ method: 'tools/call' });
      const { name, arguments: args } = request.params;

      try {
        logger.info('Tool call requested', { toolName: name, args });

        if (name === 'monitored_tool') {
          const response = {
            content: [
              {
                type: 'text',
                text: `📊 Monitored response: ${args.input}`,
              },
            ],
          };

          requestCounter.inc({ method: 'tools/call', status: 'success' });
          logger.info('Tool call completed successfully', { toolName: name });

          return response;
        }

        throw new Error(`Unknown tool: ${name}`);
      } catch (error) {
        requestCounter.inc({ method: 'tools/call', status: 'error' });
        logger.error('Tool call failed', {
          toolName: name,
          error: error.message,
          args
        });
        throw error;
      } finally {
        timer();
      }
    });
  }

  // 📊 Metrics endpoint
  async getMetrics() {
    return register.metrics();
  }

  // 🚀 Start monitored server
  start() {
    const transport = new StdioServerTransport();
    this.server.connect(transport);

    logger.info('Monitored MCP Server started');
    console.log('📊 Monitored MCP Server ready!');
  }
}

// 🌟 Initialize monitored server
const monitoredServer = new MonitoredMCPServer();
monitoredServer.start();
```

## 🎯 Advanced MCP Patterns {#Advanced-Patterns}

### 🔄 Multi-Service Orchestration:

```javascript
// orchestrator-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

class ServiceOrchestrator {
  constructor() {
    this.services = {
      database: new DatabaseService(),
      weather: new WeatherService(),
      email: new EmailService(),
    };

    this.server = new Server(
      {
        name: 'orchestrator-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  // 🔧 Setup orchestration tools
  setupHandlers() {
    this.server.setRequestHandler('tools/list', async () => {
      return {
        tools: [
          {
            name: 'daily_report',
            description: '📊 Generate daily report combining multiple services',
            inputSchema: {
              type: 'object',
              properties: {
                userId: { type: 'string', description: 'User ID' },
                includeWeather: { type: 'boolean', description: 'Include weather data' },
              },
              required: ['userId'],
            },
          },
          {
            name: 'smart_notification',
            description: '🔔 Send smart notification based on conditions',
            inputSchema: {
              type: 'object',
              properties: {
                userId: { type: 'string', description: 'User ID' },
                message: { type: 'string', description: 'Message to send' },
              },
              required: ['userId', 'message'],
            },
          },
        ],
      };
    });

    this.server.setRequestHandler('tools/call', async (request) => {
      const { name, arguments: args } = request.params;

      switch (name) {
        case 'daily_report':
          return await this.generateDailyReport(args);
        case 'smart_notification':
          return await this.sendSmartNotification(args);
        default:
          throw new Error(`Unknown tool: ${name}`);
      }
    });
  }

  // 📊 Generate comprehensive daily report
  async generateDailyReport(args) {
    try {
      // 👤 Get user data
      const userData = await this.services.database.getUser(args.userId);

      // 📈 Get user activity
      const activity = await this.services.database.getUserActivity(args.userId);

      let weatherData = '';
      if (args.includeWeather) {
        // 🌤️ Get weather for user's location
        weatherData = await this.services.weather.getWeather(userData.location);
      }

      // 📊 Compile report
      const report = {
        user: userData.name,
        date: new Date().toDateString(),
        activity: {
          tasksCompleted: activity.tasksCompleted,
          timeSpent: activity.timeSpent,
          productivity: this.calculateProductivity(activity),
        },
        weather: weatherData,
        recommendations: this.generateRecommendations(activity, weatherData),
      };

      return {
        content: [
          {
            type: 'text',
            text: this.formatReport(report),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ Error generating report: ${error.message}`,
          },
        ],
      };
    }
  }

  // 🔔 Send intelligent notification
  async sendSmartNotification(args) {
    try {
      // 👤 Get user preferences
      const userData = await this.services.database.getUser(args.userId);

      // 🌤️ Check weather conditions
      const weather = await this.services.weather.getWeather(userData.location);

      // 🎯 Customize message based on context
      let customizedMessage = args.message;

      if (weather.temperature < 10) {
        customizedMessage += '\n🧥 Don\'t forget your jacket - it\'s cold outside!';
      } else if (weather.condition === 'Rain') {
        customizedMessage += '\n☂️ Take an umbrella - it\'s raining!';
      }

      // 📧 Send email notification
      await this.services.email.send({
        to: userData.email,
        subject: 'Smart Notification',
        message: customizedMessage,
      });

      return {
        content: [
          {
            type: 'text',
            text: `✅ Smart notification sent to ${userData.name} (${userData.email})`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ Error sending notification: ${error.message}`,
          },
        ],
      };
    }
  }

  // 📊 Calculate productivity score
  calculateProductivity(activity) {
    const baseScore = (activity.tasksCompleted * 10) + (activity.timeSpent * 0.1);
    return Math.min(100, Math.round(baseScore));
  }

  // 💡 Generate personalized recommendations
  generateRecommendations(activity, weather) {
    const recommendations = [];

    if (activity.productivity < 50) {
      recommendations.push('🎯 Try the Pomodoro technique to boost productivity');
    }

    if (activity.timeSpent > 8) {
      recommendations.push('😴 Take more breaks to avoid burnout');
    }

    if (weather && weather.condition === 'Clear') {
      recommendations.push('🌞 Great weather for a outdoor break!');
    }

    return recommendations;
  }

  // 📋 Format report nicely
  formatReport(report) {
    return `📊 Daily Report for ${report.user}
📅 Date: ${report.date}

🎯 Activity Summary:
✅ Tasks Completed: ${report.activity.tasksCompleted}
⏱️ Time Spent: ${report.activity.timeSpent} hours
📈 Productivity Score: ${report.activity.productivity}/100

${report.weather ? `🌤️ Weather: ${report.weather}` : ''}

💡 Recommendations:
${report.recommendations.map(r => `• ${r}`).join('\n')}

🎉 Keep up the great work!`;
  }

  // 🚀 Start orchestrator
  start() {
    const transport = new StdioServerTransport();
    this.server.connect(transport);
    console.log('🎭 Orchestrator MCP Server ready!');
  }
}

// 📊 Mock service classes
class DatabaseService {
  async getUser(userId) {
    return {
      id: userId,
      name: 'John Doe',
      email: 'john@example.com',
      location: 'New York',
    };
  }

  async getUserActivity(userId) {
    return {
      tasksCompleted: 8,
      timeSpent: 6.5,
      projects: ['Website', 'Mobile App'],
    };
  }
}

class WeatherService {
  async getWeather(location) {
    return {
      location,
      temperature: 22,
      condition: 'Clear',
      humidity: 65,
    };
  }
}

class EmailService {
  async send(emailData) {
    console.log(`📧 Email sent to ${emailData.to}: ${emailData.subject}`);
    return { success: true, messageId: 'msg-123' };
  }
}

// 🌟 Initialize orchestrator
const orchestrator = new ServiceOrchestrator();
orchestrator.start();
```

Real-life analogy: This is like having a smart personal assistant who can coordinate between your calendar, weather app, email, and task manager to give you intelligent insights and take actions on your behalf.

## 📚 Best Practices and Tips {#Best-Practices}

### 🎯 Development Best Practices:

```javascript
// best-practices-example.js

// ✅ DO: Use clear, descriptive tool names
const goodToolName = 'calculate_monthly_budget';
const badToolName = 'calc'; // ❌ Too vague

// ✅ DO: Provide comprehensive input schemas
const goodSchema = {
  type: 'object',
  properties: {
    income: {
      type: 'number',
      description: 'Monthly income in USD',
      minimum: 0,
    },
    expenses: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          category: { type: 'string' },
          amount: { type: 'number', minimum: 0 },
        },
        required: ['category', 'amount'],
      },
    },
  },
  required: ['income', 'expenses'],
};

// ✅ DO: Handle errors gracefully
async function safeToolCall(toolFunction, params) {
  try {
    return await toolFunction(params);
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `❌ Error: ${error.message}. Please try again or contact support.`,
        },
      ],
    };
  }
}

// ✅ DO: Validate inputs thoroughly
function validateBudgetInputs(params) {
  if (!params.income || params.income <= 0) {
    throw new Error('Income must be a positive number');
  }

  if (!Array.isArray(params.expenses)) {
    throw new Error('Expenses must be an array');
  }

  for (const expense of params.expenses) {
    if (!expense.category || expense.amount < 0) {
      throw new Error('Each expense must have a category and non-negative amount');
    }
  }
}

// ✅ DO: Use consistent response formats
function createSuccessResponse(data, message) {
  return {
    content: [
      {
        type: 'text',
        text: `✅ ${message}\n\n${data}`,
      },
    ],
  };
}

// ✅ DO: Log important operations
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'mcp-server.log' }),
  ],
});

function logToolUsage(toolName, params, result) {
  logger.info('Tool executed', {
    tool: toolName,
    params: params,
    success: !!result,
    timestamp: new Date().toISOString(),
  });
}
```

### 🔒 Security Checklist:

```markdown
🔒 MCP Server Security Checklist:

✅ Input Validation:
  - Validate all input parameters
  - Sanitize string inputs
  - Check data types and ranges
  - Prevent SQL injection

✅ Rate Limiting:
  - Implement request rate limits
  - Monitor unusual usage patterns
  - Block suspicious clients

✅ Access Control:
  - Authenticate clients when possible
  - Implement role-based permissions
  - Log all access attempts

✅ Data Protection:
  - Encrypt sensitive data
  - Use secure communication channels
  - Don't log sensitive information

✅ Error Handling:
  - Don't expose internal errors
  - Provide helpful but safe error messages
  - Log errors for debugging

✅ Resource Management:
  - Limit resource usage per request
  - Implement timeouts
  - Clean up resources properly
```

### 📈 Performance Optimization:

```javascript
// performance-optimizations.js

// ✅ Connection pooling for databases
import { Pool } from 'pg';

const dbPool = new Pool({
  host: 'localhost',
  database: 'mydb',
  max: 20, // Maximum 20 connections
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// ✅ Caching for frequently accessed data
class CacheManager {
  constructor() {
    this.cache = new Map();
    this.maxSize = 1000;
    this.ttl = 5 * 60 * 1000; // 5 minutes
  }

  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      // Remove oldest entries
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(key, {
      value,
      timestamp: Date.now(),
    });
  }

  get(key) {
    const item = this.cache.get(key);

    if (!item) return null;

    // Check if expired
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    return item.value;
  }
}

// ✅ Batch operations
class BatchProcessor {
  constructor(batchSize = 10) {
    this.batchSize = batchSize;
    this.queue = [];
    this.processing = false;
  }

  async addRequest(request) {
    this.queue.push(request);

    if (this.queue.length >= this.batchSize && !this.processing) {
      await this.processBatch();
    }
  }

  async processBatch() {
    this.processing = true;
    const batch = this.queue.splice(0, this.batchSize);

    try {
      // Process all requests in parallel
      await Promise.all(batch.map(request => this.processRequest(request)));
    } catch (error) {
      console.error('Batch processing error:', error);
    } finally {
      this.processing = false;
    }
  }

  async processRequest(request) {
    // Individual request processing logic
    return request();
  }
}
```

## 🎯 Real-World Use Cases {#Real-World-Use-Cases}

### 🏢 Enterprise Integration Example:

```javascript
// enterprise-mcp-server.js
class EnterpriseMCPServer {
  constructor() {
    this.integrations = {
      salesforce: new SalesforceIntegration(),
      slack: new SlackIntegration(),
      jira: new JiraIntegration(),
      confluence: new ConfluenceIntegration(),
    };
  }

  // 🎯 Sales intelligence tool
  async getSalesInsights(params) {
    const { accountId, timeframe } = params;

    // 📊 Get data from multiple sources
    const [salesData, interactions, tickets, documents] = await Promise.all([
      this.integrations.salesforce.getAccountData(accountId),
      this.integrations.slack.getAccountInteractions(accountId),
      this.integrations.jira.getAccountTickets(accountId),
      this.integrations.confluence.getAccountDocuments(accountId),
    ]);

    // 🧠 Analyze and combine insights
    const insights = this.analyzeSalesData({
      sales: salesData,
      interactions: interactions,
      support: tickets,
      knowledge: documents,
    });

    return {
      content: [
        {
          type: 'text',
          text: `📊 Sales Insights for Account ${accountId}:\n\n${insights}`,
        },
      ],
    };
  }

  // 📈 Analyze combined data
  analyzeSalesData(data) {
    const { sales, interactions, support, knowledge } = data;

    return `💼 Account Health: ${this.calculateAccountHealth(data)}
📈 Revenue Trend: ${sales.trend}
💬 Recent Interactions: ${interactions.count} (${interactions.sentiment})
🎫 Open Tickets: ${support.open} | Resolved: ${support.resolved}
📚 Knowledge Engagement: ${knowledge.views} views

🎯 Recommendations:
${this.generateSalesRecommendations(data).join('\n')}`;
  }

  calculateAccountHealth(data) {
    // Complex scoring algorithm
    return 'Healthy 💚';
  }

  generateSalesRecommendations(data) {
    return [
      '• Schedule follow-up call',
      '• Share case studies',
      '• Address open support tickets',
    ];
  }
}
```

### 🏥 Healthcare Integration Example:

```javascript
// healthcare-mcp-server.js
class HealthcareMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: 'healthcare-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHealthcareTools();
  }

  setupHealthcareTools() {
    this.server.setRequestHandler('tools/list', async () => {
      return {
        tools: [
          {
            name: 'patient_summary',
            description: '👨‍⚕️ Generate comprehensive patient summary',
            inputSchema: {
              type: 'object',
              properties: {
                patientId: { type: 'string', description: 'Patient ID' },
                includeHistory: { type: 'boolean', description: 'Include medical history' },
              },
              required: ['patientId'],
            },
          },
          {
            name: 'medication_interaction_check',
            description: '💊 Check for drug interactions',
            inputSchema: {
              type: 'object',
              properties: {
                medications: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'List of medications',
                },
              },
              required: ['medications'],
            },
          },
          {
            name: 'appointment_scheduler',
            description: '📅 Schedule patient appointments intelligently',
            inputSchema: {
              type: 'object',
              properties: {
                patientId: { type: 'string', description: 'Patient ID' },
                appointmentType: { type: 'string', description: 'Type of appointment' },
                urgency: { type: 'string', enum: ['low', 'medium', 'high'] },
              },
              required: ['patientId', 'appointmentType'],
            },
          },
        ],
      };
    });

    this.server.setRequestHandler('tools/call', async (request) => {
      const { name, arguments: args } = request.params;

      switch (name) {
        case 'patient_summary':
          return await this.generatePatientSummary(args);
        case 'medication_interaction_check':
          return await this.checkMedicationInteractions(args);
        case 'appointment_scheduler':
          return await this.scheduleAppointment(args);
        default:
          throw new Error(`Unknown tool: ${name}`);
      }
    });
  }

  // 👨‍⚕️ Generate comprehensive patient summary
  async generatePatientSummary(args) {
    try {
      // 📋 Get patient data (mock implementation)
      const patientData = await this.getPatientData(args.patientId);
      const vitals = await this.getLatestVitals(args.patientId);
      const medications = await this.getCurrentMedications(args.patientId);
      const allergies = await this.getAllergies(args.patientId);

      let history = '';
      if (args.includeHistory) {
        history = await this.getMedicalHistory(args.patientId);
      }

      const summary = `👤 Patient Summary: ${patientData.name}
📋 ID: ${patientData.id} | Age: ${patientData.age} | Gender: ${patientData.gender}

🩺 Latest Vitals:
• Blood Pressure: ${vitals.bloodPressure}
• Heart Rate: ${vitals.heartRate} bpm
• Temperature: ${vitals.temperature}°F
• Weight: ${vitals.weight} lbs

💊 Current Medications:
${medications.map(med => `• ${med.name} - ${med.dosage}`).join('\n')}

⚠️ Allergies:
${allergies.length > 0 ? allergies.map(allergy => `• ${allergy}`).join('\n') : 'None on record'}

${history ? `📜 Medical History:\n${history}` : ''}

🚨 Alerts:
${this.generateHealthAlerts(patientData, vitals, medications).join('\n')}`;

      return {
        content: [
          {
            type: 'text',
            text: summary,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ Error generating patient summary: ${error.message}`,
          },
        ],
      };
    }
  }

  // 💊 Check medication interactions
  async checkMedicationInteractions(args) {
    try {
      const interactions = await this.analyzeInteractions(args.medications);

      if (interactions.length === 0) {
        return {
          content: [
            {
              type: 'text',
              text: '✅ No medication interactions detected.',
            },
          ],
        };
      }

      const interactionReport = `⚠️ Medication Interaction Analysis:

${interactions.map(interaction =>
  `🔴 ${interaction.severity.toUpperCase()}: ${interaction.drug1} + ${interaction.drug2}
   📝 Effect: ${interaction.effect}
   💡 Recommendation: ${interaction.recommendation}`
).join('\n\n')}

📞 Please consult with pharmacist or physician for review.`;

      return {
        content: [
          {
            type: 'text',
            text: interactionReport,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ Error checking interactions: ${error.message}`,
          },
        ],
      };
    }
  }

  // 📅 Intelligent appointment scheduling
  async scheduleAppointment(args) {
    try {
      const patientData = await this.getPatientData(args.patientId);
      const availableSlots = await this.getAvailableSlots(args.appointmentType);
      const optimalSlot = this.findOptimalSlot(availableSlots, args.urgency, patientData);

      const appointment = await this.bookAppointment({
        patientId: args.patientId,
        slot: optimalSlot,
        type: args.appointmentType,
      });

      return {
        content: [
          {
            type: 'text',
            text: `✅ Appointment Scheduled Successfully!

👤 Patient: ${patientData.name}
📅 Date: ${optimalSlot.date}
🕐 Time: ${optimalSlot.time}
🏥 Type: ${args.appointmentType}
👨‍⚕️ Provider: ${optimalSlot.provider}
📍 Location: ${optimalSlot.location}

📋 Appointment ID: ${appointment.id}

📲 Confirmation sent to: ${patientData.phone}
📧 Reminder email sent to: ${patientData.email}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ Error scheduling appointment: ${error.message}`,
          },
        ],
      };
    }
  }

  // 🔍 Mock data methods (replace with real integrations)
  async getPatientData(patientId) {
    return {
      id: patientId,
      name: 'John Smith',
      age: 45,
      gender: 'Male',
      phone: '(555) 123-4567',
      email: 'john.smith@email.com',
    };
  }

  async getLatestVitals(patientId) {
    return {
      bloodPressure: '120/80',
      heartRate: 72,
      temperature: 98.6,
      weight: 180,
    };
  }

  async getCurrentMedications(patientId) {
    return [
      { name: 'Lisinopril', dosage: '10mg daily' },
      { name: 'Metformin', dosage: '500mg twice daily' },
    ];
  }

  async getAllergies(patientId) {
    return ['Penicillin', 'Shellfish'];
  }

  generateHealthAlerts(patient, vitals, medications) {
    const alerts = [];

    if (vitals.heartRate > 100) {
      alerts.push('🔴 Elevated heart rate detected');
    }

    if (medications.length > 5) {
      alerts.push('⚠️ Multiple medications - consider interaction review');
    }

    return alerts.length > 0 ? alerts : ['✅ No current alerts'];
  }
}
```

### 🏫 Education Platform Example:

```javascript
// education-mcp-server.js
class EducationMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: 'education-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    this.setupEducationTools();
  }

  setupEducationTools() {
    this.server.setRequestHandler('tools/list', async () => {
      return {
        tools: [
          {
            name: 'student_progress_report',
            description: '📊 Generate comprehensive student progress report',
            inputSchema: {
              type: 'object',
              properties: {
                studentId: { type: 'string', description: 'Student ID' },
                subject: { type: 'string', description: 'Subject (optional)' },
                timeframe: { type: 'string', description: 'Time period (week/month/semester)' },
              },
              required: ['studentId'],
            },
          },
          {
            name: 'personalized_study_plan',
            description: '🎯 Create personalized study plan',
            inputSchema: {
              type: 'object',
              properties: {
                studentId: { type: 'string', description: 'Student ID' },
                goal: { type: 'string', description: 'Learning goal' },
                timeAvailable: { type: 'number', description: 'Hours per week' },
              },
              required: ['studentId', 'goal', 'timeAvailable'],
            },
          },
          {
            name: 'assignment_feedback',
            description: '📝 Generate detailed assignment feedback',
            inputSchema: {
              type: 'object',
              properties: {
                assignmentId: { type: 'string', description: 'Assignment ID' },
                studentId: { type: 'string', description: 'Student ID' },
                includeImprovement: { type: 'boolean', description: 'Include improvement suggestions' },
              },
              required: ['assignmentId', 'studentId'],
            },
          },
        ],
      };
    });

    this.server.setRequestHandler('tools/call', async (request) => {
      const { name, arguments: args } = request.params;

      switch (name) {
        case 'student_progress_report':
          return await this.generateProgressReport(args);
        case 'personalized_study_plan':
          return await this.createStudyPlan(args);
        case 'assignment_feedback':
          return await this.generateAssignmentFeedback(args);
        default:
          throw new Error(`Unknown tool: ${name}`);
      }
    });
  }

  // 📊 Generate student progress report
  async generateProgressReport(args) {
    try {
      const student = await this.getStudentData(args.studentId);
      const grades = await this.getGrades(args.studentId, args.subject, args.timeframe);
      const attendance = await this.getAttendance(args.studentId, args.timeframe);
      const assignments = await this.getAssignments(args.studentId, args.timeframe);

      const report = `📊 Progress Report: ${student.name}
🆔 Student ID: ${student.id} | Grade: ${student.grade} | Class: ${student.class}

📈 Academic Performance:
${this.formatGrades(grades)}

📅 Attendance: ${attendance.present}/${attendance.total} days (${attendance.percentage}%)

📝 Assignment Status:
• Completed: ${assignments.completed}
• Pending: ${assignments.pending}
• Overdue: ${assignments.overdue}
• Average Score: ${assignments.averageScore}%

🎯 Performance Analysis:
${this.analyzePerformance(grades, attendance, assignments).join('\n')}

📈 Trends:
${this.identifyTrends(grades).join('\n')}

💡 Recommendations:
${this.generateRecommendations(student, grades, attendance, assignments).join('\n')}`;

      return {
        content: [
          {
            type: 'text',
            text: report,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ Error generating progress report: ${error.message}`,
          },
        ],
      };
    }
  }

  // 🎯 Create personalized study plan
  async createStudyPlan(args) {
    try {
      const student = await this.getStudentData(args.studentId);
      const weakAreas = await this.identifyWeakAreas(args.studentId);
      const learningStyle = await this.getLearningStyle(args.studentId);

      const studyPlan = this.generateStudyPlan({
        student,
        goal: args.goal,
        timeAvailable: args.timeAvailable,
        weakAreas,
        learningStyle,
      });

      return {
        content: [
          {
            type: 'text',
            text: studyPlan,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ Error creating study plan: ${error.message}`,
          },
        ],
      };
    }
  }

  generateStudyPlan(data) {
    const { student, goal, timeAvailable, weakAreas, learningStyle } = data;

    return `🎯 Personalized Study Plan for ${student.name}

🎯 Goal: ${goal}
⏰ Time Available: ${timeAvailable} hours/week
🧠 Learning Style: ${learningStyle.primary}

📚 Weekly Schedule:
${this.createWeeklySchedule(timeAvailable, weakAreas)}

🔍 Focus Areas:
${weakAreas.map(area => `• ${area.subject}: ${area.topics.join(', ')}`).join('\n')}

📖 Recommended Resources:
${this.getRecommendedResources(weakAreas, learningStyle)}

🎯 Milestones:
${this.createMilestones(goal).join('\n')}

📊 Progress Tracking:
• Weekly self-assessment quizzes
• Bi-weekly review sessions
• Monthly progress evaluation`;
  }

  createWeeklySchedule(hoursAvailable, weakAreas) {
    const schedule = [];
    const daysOfWeek = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    const hoursPerDay = Math.ceil(hoursAvailable / 7);

    daysOfWeek.forEach((day, index) => {
      if (index < hoursAvailable) {
        const area = weakAreas[index % weakAreas.length];
        schedule.push(`${day}: ${hoursPerDay}h - ${area.subject} (${area.priority})`);
      }
    });

    return schedule.join('\n');
  }

  // 📝 Generate assignment feedback
  async generateAssignmentFeedback(args) {
    try {
      const assignment = await this.getAssignment(args.assignmentId);
      const submission = await this.getSubmission(args.assignmentId, args.studentId);
      const rubric = await this.getRubric(args.assignmentId);

      const feedback = this.analyzeFeedback(assignment, submission, rubric);

      let report = `📝 Assignment Feedback

📋 Assignment: ${assignment.title}
👤 Student: ${submission.studentName}
📅 Submitted: ${submission.submittedAt}
⭐ Score: ${submission.score}/${assignment.maxScore} (${submission.percentage}%)

🎯 Strengths:
${feedback.strengths.join('\n')}

🔍 Areas for Improvement:
${feedback.improvements.join('\n')}

📊 Rubric Breakdown:
${this.formatRubricScores(submission.rubricScores)}`;

      if (args.includeImprovement) {
        report += `\n\n💡 Specific Improvement Suggestions:
${feedback.suggestions.join('\n')}

📚 Recommended Resources:
${feedback.resources.join('\n')}`;
      }

      return {
        content: [
          {
            type: 'text',
            text: report,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ Error generating feedback: ${error.message}`,
          },
        ],
      };
    }
  }

  // 🔍 Mock data methods
  async getStudentData(studentId) {
    return {
      id: studentId,
      name: 'Emma Johnson',
      grade: '10th Grade',
      class: '10-A',
    };
  }

  async getGrades(studentId, subject, timeframe) {
    return {
      math: 85,
      science: 92,
      english: 78,
      history: 88,
    };
  }

  async identifyWeakAreas(studentId) {
    return [
      {
        subject: 'Mathematics',
        topics: ['Algebra', 'Geometry'],
        priority: 'High',
      },
      {
        subject: 'English',
        topics: ['Essay Writing', 'Grammar'],
        priority: 'Medium',
      },
    ];
  }
}
```

## 🏁 Conclusion and Next Steps {#Conclusion}

Congratulations! 🎉 You've just completed a comprehensive journey through the world of MCP Servers. Let's recap what you've mastered:

### 🎯 What You've Learned:

#### 🏗️ Core Concepts:
- 📡 MCP Protocol - The bridge between AI and external services
- 🔧 Tools - Functions that AI can execute
- 📚 Resources - Data sources AI can access
- 🌉 Server Architecture - How everything connects together

#### 💻 Technical Skills:
- ⚡ Basic Server Setup - Your first "Hello World" MCP server
- 🗄️ Database Integration - Connecting to SQLite and other databases
- 🌐 API Integration - Weather services and external APIs
- 🔒 Security Implementation - Rate limiting, validation, encryption
- 🧪 Testing Strategies - Unit tests and manual testing
- 🚀 Deployment - Docker, monitoring, and production setup

#### 🎪 Advanced Patterns:
- 🎭 Service Orchestration - Combining multiple services intelligently
- 🏢 Enterprise Integration - Real-world business applications
- 🏥 Domain-Specific Solutions - Healthcare, education, and more
- 📊 Performance Optimization - Caching, batching, connection pooling

### 🚀 Your MCP Journey Roadmap:

#### 🌱 Beginner Level (You are here!):
- ✅ Understand MCP concepts
- ✅ Build basic tools and resources
- ✅ Handle simple integrations
- ✅ Implement basic security

#### 🌿 Intermediate Level (Next steps):
- 🎯 Build Complex Integrations - Multi-service orchestration
- 🔄 Implement Workflows - Chain multiple tools together
- 📊 Add Analytics - Track usage and performance
- 🎨 Create Domain-Specific Servers - For your industry
- 🔧 Optimize Performance - Caching and scaling

#### 🌳 Advanced Level (Future goals):
- 🏗️ Microservices Architecture - Distributed MCP systems
- 🤖 AI-Powered Tools - Tools that use AI internally
- 🌐 Protocol Extensions - Custom MCP capabilities
- 🏢 Enterprise Solutions - Large-scale deployments
- 📚 Contribute to MCP - Help improve the protocol

### 💡 Project Ideas to Practice:

#### 🏠 Personal Projects:
1. 📝 Personal Assistant Server - Calendar, email, tasks, weather
2. 💰 Finance Manager - Budget tracking, expense analysis
3. 🏃‍♂️ Fitness Tracker - Workout plans, nutrition, progress
4. 📚 Learning Companion - Study schedules, progress tracking
5. 🏡 Smart Home Controller - IoT device integration

#### 🏢 Business Projects:
1. 📊 CRM Integration - Sales data, customer insights
2. 📈 Analytics Dashboard - Business metrics, reporting
3. 🎫 Support Ticket System - Customer service automation
4. 📦 Inventory Manager - Stock tracking, reorder alerts
5. 👥 HR Assistant - Employee data, scheduling, reviews

#### 🌍 Community Projects:
1. 🌱 Environmental Monitor - Air quality, weather data
2. 🚌 Transit Information - Bus schedules, route planning
3. 📰 News Aggregator - Local news, event information
4. 🎭 Event Organizer - Community events, RSVPs
5. 📖 Library System - Book recommendations, availability

### 🔗 Additional Resources:

#### 📚 Learn More:
- MCP Official Documentation - Latest specifications and examples
- AI Integration Patterns - Best practices for AI-tool communication
- API Design Principles - Creating robust, scalable interfaces
- Security in AI Systems - Protecting AI-enabled applications

#### 🛠️ Tools and Libraries:
- MCP SDK - Official development kit
- Testing Frameworks - Vitest, Jest, or your preferred framework
- Monitoring Tools - Prometheus, Grafana for production monitoring
- Deployment Platforms - Docker, Kubernetes, cloud services

#### 🤝 Community:
- GitHub Repositories - Explore open-source MCP servers
- Developer Forums - Ask questions, share experiences
- AI Developer Communities - Connect with other AI builders
- Local Meetups - Find AI and development groups near you

### 🎯 Remember:

> "The best way to learn MCP is by building MCP servers!"

Start with simple projects and gradually increase complexity. Every expert was once a beginner, and every professional was once an amateur. The key is to:

- 🔄 Practice Regularly - Build something new each week
- 🧪 Experiment Fearlessly - Try new integrations and patterns
- 🤝 Share Your Work - Get feedback from the community
- 📚 Keep Learning - Stay updated with MCP developments
- 🎯 Solve Real Problems - Build tools that genuinely help people

### 🌟 Final Thoughts:

MCP Servers represent the future of AI integration - a standardized way for AI systems to interact with the digital world. By mastering MCP, you're not just learning a technology; you're preparing for a future where AI assistants can seamlessly work with any service or system.

Whether you're building personal productivity tools, enterprise integrations, or the next generation of AI-powered applications, the skills you've learned here will serve as your foundation.

Go forth and build amazing things! 🚀

The world needs more AI integrations, and now you have the knowledge to create them. Start small, think big, and remember - every great MCP server started with a simple `console.log('MCP Server ready!')`.

Happy Building! 🛠️👨‍💻👩‍💻

---

*Found this guide helpful? Share it with other developers who want to build the future of AI integration! 🤝*

### 🔖 Quick Reference:

```javascript
// 🚀 Quick MCP Server Template
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const server = new Server({
  name: 'my-awesome-server',
  version: '1.0.0',
}, {
  capabilities: { tools: {}, resources: {} }
});

// Add your tools here
server.setRequestHandler('tools/list', async () => ({ tools: [] }));
server.setRequestHandler('tools/call', async (request) => { /* handle */ });

// Start server
const transport = new StdioServerTransport();
server.connect(transport);
console.log('🌟 MCP Server ready!');
```

Save this template and start building your next MCP server today! ⭐
