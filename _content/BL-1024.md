---
Id: 1024 
Title: Factory Design Pattern  
Author: technoayan  
Tags: Design-Pattern Factory  
Topic: LLD  
Abstract: Understand the Factory Design Pattern in Java with real-life analogies, clean code examples, and best practices. Learn how it promotes loose coupling and simplifies object creation.  
HeaderImage: /BL-1015/factory.png  

isPublished: true  
---

# ğŸ­ Factory Design Pattern in Java

The **Factory Design Pattern** is a **creational design pattern** used to create objects **without exposing the creation logic** to the client.

Instead of using `new` keyword directly, we **delegate the object creation** to a factory method.

---

## ğŸ¯ Real-Life Analogy

ğŸ§ƒ Imagine ordering a drink at a juice shop.

You don't care how the juice is made â€“ you just say "Give me an **Orange Juice**", and the shop handles the rest.

Similarly, with the Factory Pattern, the **factory class creates the object** based on your input.

---

## ğŸ”§ When to Use It?

* When the **object creation logic is complex** or depends on conditions.
* When you want to **centralize creation** logic.
* When you need **loose coupling** between classes.

---

## ğŸ”¥ Basic Example â€“ Shape Factory

### ğŸ”¸ Step 1: Create a common interface

```java
interface Shape {
    void draw();
}
```

---

### ğŸ”¸ Step 2: Implement different shapes

```java
class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing a Circle");
    }
}

class Square implements Shape {
    public void draw() {
        System.out.println("Drawing a Square");
    }
}
```

---

### ğŸ”¸ Step 3: Create a Factory class

```java
class ShapeFactory {
    public Shape getShape(String shapeType) {
        if (shapeType == null) return null;

        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("SQUARE")) {
            return new Square();
        }

        return null;
    }
}
```

---

### ğŸ”¸ Step 4: Use Factory in Main Class

```java
public class Main {
    public static void main(String[] args) {
        ShapeFactory factory = new ShapeFactory();

        Shape shape1 = factory.getShape("CIRCLE");
        shape1.draw();

        Shape shape2 = factory.getShape("SQUARE");
        shape2.draw();
    }
}
```

---

## âœ… Output

```
Drawing a Circle  
Drawing a Square
```

---

## ğŸ“Œ Key Concepts

| Concept               | Description                                       |
| --------------------- | ------------------------------------------------- |
| Loose Coupling        | Client doesnâ€™t care how objects are created       |
| Reusability           | Easy to manage and extend object creation         |
| Encapsulation         | Hides object instantiation logic                  |
| Open/Closed Principle | Easy to add new shapes without modifying old code |

---

## ğŸ§  Real-World Use Case: Notification Service

Suppose your app supports notifications via Email and SMS. The client should just say â€œSend Notificationâ€ â€” the factory decides how.

---

### ğŸ”¸ Step 1: Notification Interface

```java
interface Notification {
    void notifyUser();
}
```

---

### ğŸ”¸ Step 2: Implementations

```java
class EmailNotification implements Notification {
    public void notifyUser() {
        System.out.println("Sending Email Notification");
    }
}

class SMSNotification implements Notification {
    public void notifyUser() {
        System.out.println("Sending SMS Notification");
    }
}
```

---

### ğŸ”¸ Step 3: Factory Class

```java
class NotificationFactory {
    public Notification createNotification(String type) {
        if (type == null || type.isEmpty()) return null;

        if (type.equalsIgnoreCase("EMAIL")) {
            return new EmailNotification();
        } else if (type.equalsIgnoreCase("SMS")) {
            return new SMSNotification();
        }

        return null;
    }
}
```

---

### ğŸ”¸ Step 4: Main Class

```java
public class NotificationService {
    public static void main(String[] args) {
        NotificationFactory factory = new NotificationFactory();

        Notification email = factory.createNotification("EMAIL");
        email.notifyUser();

        Notification sms = factory.createNotification("SMS");
        sms.notifyUser();
    }
}
```

---

## âœ… Output

```
Sending Email Notification  
Sending SMS Notification
```

---

## ğŸš« Anti-Patterns to Avoid

* âŒ Huge `if-else` chains in factory â†’ use **enum or config** to clean it later.
* âŒ Mixing business logic inside factory â†’ keep factory focused on **object creation** only.

---

## ğŸ§  Interview Q\&A

**Q:** What pattern category does Factory belong to?
**A:** Creational

**Q:** What's the difference between Factory and Abstract Factory?
**A:**

* **Factory** â†’ returns one family/type of object.
* **Abstract Factory** â†’ returns **related objects** from multiple factories.

**Q:** Why not just use `new`?
**A:** Because `new` tightly couples the client with the implementation. Factory gives you **flexibility and control**.

---

## ğŸ“š Summary

* âœ… Factory Pattern helps in creating objects in a clean and controlled way.
* ğŸ§± Promotes **loose coupling**, **reusability**, and **maintainability**.
* ğŸ“¦ Useful when object creation is **conditional**, **dynamic**, or **complex**.

---
