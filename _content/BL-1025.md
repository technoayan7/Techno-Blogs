---
Id: 1025  
Title: Strategy Design Pattern  
Author: technoayan  
Tags: Design-Pattern Strategy  
Topic: LLD  
Abstract: Master the Strategy Design Pattern in Java with simple explanations, real-world analogies, and working code examples. Learn how to write flexible and extensible code using behavior encapsulation.  
HeaderImage: /BL-1016/strategy.png  

isPublished: true  
---

# ğŸ§  Strategy Design Pattern in Java

The **Strategy Design Pattern** lets you define a **family of algorithms**, encapsulate each one, and make them **interchangeable** at runtime.

It's part of the **behavioral design patterns** category and is widely used in real-world applications.

---

## ğŸ¯ Real-Life Analogy

ğŸ§  Think of a **Google Maps app**.

When you want directions, you can choose your route:

* ğŸš¶ Walk
* ğŸš— Drive
* ğŸš´ Cycle

The app **uses a different strategy (algorithm)** based on what you choose â€” but the interface remains the same: **"Give me directions."**

---

## ğŸ”§ When to Use Strategy Pattern?

* When you have **multiple algorithms or behaviors** for the same task.
* When you want to **change behavior at runtime**.
* To **avoid massive `if-else` or `switch`** logic blocks.

---

## ğŸ”¥ Example â€“ Payment Strategies

Letâ€™s say youâ€™re building an e-commerce app that supports:

* ğŸ’³ Credit Card
* ğŸ§¾ UPI
* ğŸ¦ Net Banking

---

### ğŸ”¸ Step 1: Define a Strategy Interface

```java
interface PaymentStrategy {
    void pay(int amount);
}
```

---

### ğŸ”¸ Step 2: Implement Concrete Strategies

```java
class CreditCardPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using Credit Card");
    }
}

class UpiPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using UPI");
    }
}

class NetBankingPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using Net Banking");
    }
}
```

---

### ğŸ”¸ Step 3: Context Class (uses a strategy)

```java
class PaymentContext {
    private PaymentStrategy strategy;

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void payAmount(int amount) {
        if (strategy == null) {
            System.out.println("Please select a payment method.");
            return;
        }
        strategy.pay(amount);
    }
}
```

---

### ğŸ”¸ Step 4: Main Class to Test

```java
public class PaymentApp {
    public static void main(String[] args) {
        PaymentContext context = new PaymentContext();

        // Using UPI
        context.setPaymentStrategy(new UpiPayment());
        context.payAmount(500);

        // Using Credit Card
        context.setPaymentStrategy(new CreditCardPayment());
        context.payAmount(1200);

        // Using Net Banking
        context.setPaymentStrategy(new NetBankingPayment());
        context.payAmount(800);
    }
}
```

---

## âœ… Output

```
Paid â‚¹500 using UPI  
Paid â‚¹1200 using Credit Card  
Paid â‚¹800 using Net Banking
```

---

## ğŸ§  Why Strategy Pattern?

| Feature       | Benefit                                            |
| ------------- | -------------------------------------------------- |
| Encapsulation | Each strategy is isolated                          |
| Extensibility | Add new strategies without modifying existing code |
| Reusability   | Reuse strategies across contexts                   |
| OCP Compliant | Open for extension, closed for modification        |

---

## ğŸš« Without Strategy: Massive If-Else Block âŒ

```java
public class PaymentService {
    public void pay(String type, int amount) {
        if (type.equals("UPI")) {
            // UPI logic
        } else if (type.equals("CREDIT")) {
            // Credit card logic
        } else if (type.equals("BANK")) {
            // Net banking logic
        }
        // More logic = more pain
    }
}
```

ğŸ‘ This becomes hard to maintain and violates **SRP** and **OCP**.

---

## ğŸ”„ Bonus Example â€“ Sorting Strategies

You can apply the Strategy pattern to choose **different sorting algorithms** dynamically.

```java
interface SortStrategy {
    void sort(int[] arr);
}

class BubbleSort implements SortStrategy {
    public void sort(int[] arr) {
        System.out.println("Sorting using Bubble Sort...");
        // logic here
    }
}

class QuickSort implements SortStrategy {
    public void sort(int[] arr) {
        System.out.println("Sorting using Quick Sort...");
        // logic here
    }
}
```

---

## ğŸ§  Interview Q\&A

**Q:** What type of pattern is Strategy?
**A:** Behavioral pattern.

**Q:** Difference between Strategy and State Pattern?
**A:**

* **Strategy**: Focuses on selecting algorithms dynamically.
* **State**: Focuses on objectâ€™s behavior change based on internal state.

**Q:** Does Strategy follow SOLID principles?
**A:** Yes â€” especially **Open/Closed** and **Single Responsibility**.

---

## ğŸ“š Summary

* âœ… Strategy Pattern allows dynamic switching between different algorithms.
* ğŸ§© Promotes loose coupling and clean design.
* ğŸš« Avoids hardcoding and conditional chaos.
* ğŸ› ï¸ Easy to maintain, extend, and test.

---
